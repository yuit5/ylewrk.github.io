{
  "data": {
    "lesson": {
      "id": 930692,
      "key": "3d93a126-42ab-4b02-8f13-b39eb91149c0",
      "title": "Variables and Memory",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "In this lesson the process memory model is introduced, which contains the two fundamental memory areas heap and stack, which play an important role in C++.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/3d93a126-42ab-4b02-8f13-b39eb91149c0/930692/1570750130806/Variables+and+Memory+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/3d93a126-42ab-4b02-8f13-b39eb91149c0/930692/1570750128422/Variables+and+Memory+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 930851,
          "key": "d1025d19-ba85-47e1-a60d-f7450cb6a4b5",
          "title": "The Process Memory Model",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d1025d19-ba85-47e1-a60d-f7450cb6a4b5",
            "completed_at": "2020-05-14T21:53:56.564Z",
            "last_viewed_at": "2020-06-04T20:52:31.974Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 930854,
              "key": "430691b0-3041-4389-b272-a068c43d0e14",
              "title": "ND213 C03 L02 01.1 The Process Memory Model HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "tTx08nfDWp0",
                "china_cdn_id": "tTx08nfDWp0.mp4"
              }
            },
            {
              "id": 930855,
              "key": "31112718-8a43-48aa-8faf-d39f9c591e8b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## The Process Memory Model\nAs we have seen in the previous lesson, each program is assigned its own virtual memory by the operating system. This address space is arranged in a linear fashion with one block of data being stored at each address. It is also divided into several distinct areas as illustrated by the figure below: ",
              "instructor_notes": ""
            },
            {
              "id": 930856,
              "key": "7b7e93b6-2b77-4a6b-b9f1-8a2abbd0905e",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2019/September/5d892a17_c21-fig1/c21-fig1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/7b7e93b6-2b77-4a6b-b9f1-8a2abbd0905e",
              "caption": "",
              "alt": "Image showing the memory address space being divided into categories including the heap and stack.",
              "width": 1162,
              "height": 1162,
              "instructor_notes": null
            },
            {
              "id": 930857,
              "key": "d95e99ef-047b-4493-83e7-7efa41d91b6a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The last address `0cFFFFFFFF`  converts to the decimal `4.294.967.295` , which is the total amount of memory blocks that can theoretically addressed in a 32 bit operating system - hence the well-known limit of 4GB of memory.  On a 64 bit system, the available space is significantly (!) larger. Also, the addresses are stored with 8 bytes instead of 4 bytes. \n\nFrom a programming perspective though, we are not able to use the entire address space. Instead, the blocks \"OS Kernel Space\" and \"Text\" are reserved for the operating system. In kernel space, only the most trusted code is executed - it is fully maintained by the operating system and serves as an interface between the user code and the system kernel. In this course, we will not be directly concerned with this part of memory. The section called 'text' holds the program code generated by the compiler and linker. As with the kernel space, we will not be using this block directly in this course. Let us now take a look at the remaining blocks, starting from the top: \n\n1.  The **stack** is a contiguous memory block with a fixed maximum size. If a program exceeds this size, it will crash. The stack is used for storing automatically allocated variables such as local variables or function parameters. If there are multiple threads in a program, then each thread has its own stack memory. New memory on the stack is allocated when the path of execution enters a scope and freed again once the scope is left.  It is important to know that the stack is managed \"automatically\" by the compiler, which means we do not have to concern ourselves with allocation and deallocation.\n\n2. The **heap** (also called \"free store\" in C++) is where data with dynamic storage lives. It is shared among multiple threads in a program, which means that memory management for the heap needs to take concurrency into account. This makes memory allocations in the heap more complicated than stack allocations. In general, managing memory on the heap is more (computationally) expensive for the operating system, which makes it slower than stack memory. Contrary to the stack, the heap is not managed automatically by the system, but by the programmer. If memory is allocated on the heap, it is the programmer’s responsibility to free it again when it is no longer needed. If the programmer manages the heap poorly or not at all, there will be trouble.\n\n3. The **BSS** (Block Started by Symbol) segment is used in many compilers and linkers for a segment that contains global and static variables that are initialized with zero values. This memory area is suitable, for example, for arrays that are not initialized with predefined values. \n\n4. The **Data** segment serves the same purpose as the BSS segment with the major difference being that variables in the Data segment have been initialized with a value other than zero. Memory for variables in the Data segment (and in BSS) is allocated once when a program is run and persists throughout its lifetime.\n\n\n## Memory Allocation in C++\nNow that we have an understanding of the available process memory, let us take a look at memory allocation in C++. \n\nNot every variable in a program has a permanently assigned area of memory. The term **allocate** refers to the process of assigning an area of memory to a variable to store its value. A variable is **deallocated** when the system reclaims the memory from the variable, so it no longer has an area to store its value.\n\nGenerally, three basic types of memory allocation are supported: \n\n1. **Static memory allocation** is performed for static and global variables, which are stored in the BSS and Data segment. Memory for these types of variables is allocated once when your program is run and persists throughout the life of your program.\n\n2. **Automatic memory allocation** is performed for function parameters as well as local variables, which are stored on the stack. Memory for these types of variables is allocated when the path of execution enters a scope and freed again once the scope is left.\n\n3. **Dynamic memory allocation** is a possibility for programs to request memory from the operating system at runtime when needed. This is the major difference to automatic and static allocation, where the size of the variable must be known at compile time. Dynamic memory allocation is not performed on the limited stack but on the heap and is thus (almost) only limited by the size of the address space. \n\nFrom a programmer’s perspective, stack and heap are the most important areas of program memory. Hence, in the following lessons, let us look at these two in turn.",
              "instructor_notes": ""
            },
            {
              "id": 930858,
              "key": "36dfa8af-d0b2-4164-9e6a-268d37c20168",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Outro",
              "instructor_notes": ""
            },
            {
              "id": 930859,
              "key": "2d625ddb-9cc1-4b76-bd25-e4011de69b32",
              "title": "ND213 C03 L02 01.2 The Process Memory Model HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "JrxMUJWfKhA",
                "china_cdn_id": "JrxMUJWfKhA.mp4"
              }
            }
          ]
        },
        {
          "id": 930852,
          "key": "9cc53eda-5e84-4463-b968-1b1324f6a7c3",
          "title": "Automatic Memory Allocation (The Stack)",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "9cc53eda-5e84-4463-b968-1b1324f6a7c3",
            "completed_at": "2020-06-04T20:52:37.427Z",
            "last_viewed_at": "2020-06-04T20:52:37.293Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 930860,
              "key": "bbdf9b6e-1112-49cb-a55f-7bd5cf853f0e",
              "title": "ND213 C03 L02 02.1 Automatic Memory Allocation (The Stack) HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "PlBDxf5ujyo",
                "china_cdn_id": "PlBDxf5ujyo.mp4"
              }
            },
            {
              "id": 930861,
              "key": "1b0b6d33-69bc-4f40-9b16-13e050918d99",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Properties of Stack Memory\nIn the available literature on C++, the terms *stack* and *heap* are used regularly, even though this is not formally correct: C++ has the *free space*, *storage classes* and the *storage duration* of objects. However, since  stack and heap are widely used in the C++ community, we will also use it throughout this course. Should you come across the above-mentioned terms in a book or tutorial on the subject, you now know that they refer to the same concepts as stack and heap do. \n\nAs mentioned in the last section, the stack is the place in virtual memory where the local variables reside, including arguments to functions. Each time a function is called, the stack grows (from top to bottom) and each time a function returns, the stack contracts. When using multiple threads (as in concurrent programming), it is important to know that each thread has its own stack memory - which can be considered thread-safe. \n\nIn the following, a short list of key properties of the stack is listed: \n\n1. The stack is a **contiguous block of memory**. It will not become fragmented (as opposed to the heap) and it has a fixed maximum size. \n\n2. When the **maximum size of the stack** memory is exceeded, a program will crash. \n\n3. Allocating and deallocating **memory is fast** on the stack. It only involves moving the stack pointer to a new position. \n\nThe following diagram shows the stack memory during a function call:",
              "instructor_notes": ""
            },
            {
              "id": 930862,
              "key": "10db7b7b-2f76-4773-a8db-66a7132c12c2",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2019/September/5d8b9db1_c22-fig1/c22-fig1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/10db7b7b-2f76-4773-a8db-66a7132c12c2",
              "caption": "",
              "alt": "",
              "width": 1081,
              "height": 787,
              "instructor_notes": null
            },
            {
              "id": 930864,
              "key": "1d82c481-3324-4401-919b-1c1af9729f54",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In the example, the variable `x` is created on the stack within the scope of main. Then, a stack frame which represents the function `Add` and its variables is pushed to the stack, moving the stack pointer further downwards. It can be seen that this includes the local variables `a` and `b`, as well as the return address, a base pointer and finally the return value `s`.  \n\n\nIn the following, let us dig a little more deeply and conduct some experiments with variables on the stack.\n\n## Stack Growth and Contraction",
              "instructor_notes": ""
            },
            {
              "id": 940364,
              "key": "768a9a3e-7f72-4a0c-bb83-e1c9310ad349",
              "title": "ND213 C03 L02 02.2 Automatic Memory Allocation (The Stack) SC",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "W62TL4_NhEs",
                "china_cdn_id": "W62TL4_NhEs.mp4"
              }
            },
            {
              "id": 930863,
              "key": "b21b094a-e043-41f9-9e52-6c3c179aea00",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r859981c930852xJUPYTERLnl6lxzen",
              "pool_id": "jupyterlab",
              "view_id": "jupyter-lab-k25ps",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "pageEnd": "",
                    "pageStart": "",
                    "allowSubmit": false,
                    "defaultPath": "/",
                    "actionButtonText": ""
                  },
                  "kind": "jupyter-lab"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 930870,
              "key": "cea9b8b3-1237-4abc-a6a9-453924dd7646",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Outro",
              "instructor_notes": ""
            },
            {
              "id": 930871,
              "key": "3bd4427d-d301-43d9-954f-49259c20ab73",
              "title": "ND213 C03 L02 02.3 Automatic Memory Allocation (The Stack) HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "gXdpjZiL7m8",
                "china_cdn_id": "gXdpjZiL7m8.mp4"
              }
            },
            {
              "id": 930872,
              "key": "20b4b092-a4c5-49e6-ab76-c3886b2a713c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Before we take a look at the heap memory in the next lesson, let us briefly revisit the principles of call-by-value and call-by-reference with regard to stack usage. \n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 930853,
          "key": "a4558a66-f4fe-4ddb-8f87-cc8e95a03266",
          "title": "Call-By-Value vs. Call-By-Reference",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "a4558a66-f4fe-4ddb-8f87-cc8e95a03266",
            "completed_at": "2020-06-04T20:53:22.108Z",
            "last_viewed_at": "2020-06-04T20:53:21.425Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 930873,
              "key": "07cab5a1-4dd3-47bb-bcf0-6a094fb30d0e",
              "title": "ND213 C03 L02 03.1 Call-By-Value Vs. Call-By-Reference HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "xBO3kdZTHyc",
                "china_cdn_id": "xBO3kdZTHyc.mp4"
              }
            },
            {
              "id": 930874,
              "key": "db27c546-78f9-4f04-a1ba-c673aecc4452",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "When passing parameters to a function in C++, there is a variety of strategies a programmer can choose from. In this section, we will take a look at these in turn from the perspective of stack usage. First, we will briefly revisit the definition of scope, as well as the strategies call-by-value and call-by-reference. Then, we will look at the amount of stack memory used by these methods. ",
              "instructor_notes": ""
            },
            {
              "id": 930997,
              "key": "1d6534ac-842d-423a-8927-7c534cf50c0a",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r859981c930853xJUPYTERLykrdgbtw",
              "pool_id": "jupyterlab",
              "view_id": "jupyter-lab-21dft",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "videos": [
                      {
                        "id": "101683",
                        "duration": 297,
                        "subtitles": [],
                        "topher_id": "2ad52251-dbfa-11e9-b7ab-0242ac11000d",
                        "youtube_id": "-H0s49ukZzQ",
                        "transcodings": {
                          "uri_hls": "https://video.udacity-data.com/topher/2019/September/5d855997_nd213-c03-l02-03.2-call-by-value-vs.-call-by-reference-sc/hls/playlist.m3u8",
                          "uri_480p_mp4": "https://video.udacity-data.com/topher/2019/September/5d855997_nd213-c03-l02-03.2-call-by-value-vs.-call-by-reference-sc/nd213-c03-l02-03.2-call-by-value-vs.-call-by-reference-sc_480p.mp4",
                          "uri_720p_mp4": "https://video.udacity-data.com/topher/2019/September/5d855997_nd213-c03-l02-03.2-call-by-value-vs.-call-by-reference-sc/nd213-c03-l02-03.2-call-by-value-vs.-call-by-reference-sc_720p.mp4",
                          "uri_480p_1000kbps_mp4": "https://video.udacity-data.com/topher/2019/September/5d855997_nd213-c03-l02-03.2-call-by-value-vs.-call-by-reference-sc/nd213-c03-l02-03.2-call-by-value-vs.-call-by-reference-sc_480p_1000kbps.mp4"
                        }
                      }
                    ],
                    "pageEnd": "",
                    "pageStart": "",
                    "allowSubmit": false,
                    "defaultPath": "/",
                    "actionButtonText": ""
                  },
                  "kind": "jupyter-lab"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 931017,
              "key": "f3a8a777-ef13-4aa4-bcfc-1b0d76f46965",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Outro",
              "instructor_notes": ""
            },
            {
              "id": 931016,
              "key": "83d6c0a0-044e-4fde-aca8-5111a5b5d60e",
              "title": "ND213 C03 L02 03.3 Call-By-Value Vs. Call-By-Reference HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "S4NSWgZyvT4",
                "china_cdn_id": "S4NSWgZyvT4.mp4"
              }
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "starter_files",
      "reason": "prefer master_archive_id"
    },
    {
      "name": "starter_files",
      "reason": "prefer master_archive_id"
    }
  ]
}