WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:05.000
では このクラスの絶対的本質である A-star について説明します

00:00:05.000 --> 00:00:10.000
A-star は 何年も前にスタンフォードの Nels Nelson によって作成されました

00:00:10.000 --> 00:00:14.000
これは検索アルゴリズムの確率変数で すべてのノードを展開するよりも効率的です

00:00:14.000 --> 00:00:19.000
ここまでやってきて オープンリストのノードを徐々に展開する検索のメカニズムを理解しているなら

00:00:19.000 --> 00:00:24.000
A-star はほとんどそれと同じようですが

00:00:24.000 --> 00:00:26.000
ある意味まったく別物です

00:00:26.000 --> 00:00:30.000
A-star を解説するために前と同じグリッドを使いますが

00:00:30.000 --> 00:00:33.000
異なる障害設定になっています

00:00:33.000 --> 00:00:36.000
これが A-star をうまく実行する方法の 1 つです

00:00:36.000 --> 00:00:39.000
もちろん ここを下に行こうとしますが

00:00:39.000 --> 00:00:43.000
ここではまだゴールまでの最適な行き方を検索しなければなりません

00:00:43.000 --> 00:00:46.000
ここのコードでも同じ問題です ここにみんな 1 が並んでいるのがわかります

00:00:46.000 --> 00:00:49.000
スタートセットはここで ゴールセットはここです

00:00:49.000 --> 00:00:56.000
個のコードを実行して拡張リストを提供すると 前にプログラムしたものが

00:00:56.000 --> 00:01:01.000
ここから下に展開したものがあるのがわかります

00:01:01.000 --> 00:01:06.000
でも オースンスペースに展開されてしまいます

00:01:06.000 --> 00:01:11.000
でオープンスペースに斜めに展開していき 最終的にゴールノード 15 にたどり着きます

00:01:11.000 --> 00:01:14.000
このポイントまで 16 展開行われました

00:01:14.000 --> 00:01:18.000
A-star に切り替えてコードをもう一度実行してみます

00:01:18.000 --> 00:01:24.000
すると 10 回の展開のみ 0 から 9 でこのポイントにたどり着きます

00:01:24.000 --> 00:01:28.000
よって 4 つ下に展開して その後まっすぐゴールに向かって展開します

00:01:28.000 --> 00:01:33.000
このあたりは触りません どういうわけか 魔法のように

00:01:33.000 --> 00:01:37.000
このあたりのゴールへのパスは真っ直ぐ行くより長くなることがわかっているのです

00:01:37.000 --> 00:01:38.000
うそは言っていません

00:01:38.000 --> 00:01:40.000
ここでは真っ直ぐのパスだとは言いませんでした

00:01:40.000 --> 00:01:44.000
そのため ここのゴールの横に障害を置いて A-star をもう一度実行します

00:01:44.000 --> 00:01:47.000
ここの 7 までは展開されないことがわかりますが

00:01:47.000 --> 00:01:50.000
2番目のラインのここに移動すると

00:01:50.000 --> 00:01:53.000
ここまで展開して もう一度ゴールにたどり着きます

00:01:53.000 --> 00:01:56.000
よって 最小限必要な作業を行って

00:01:56.000 --> 00:01:57.000
ゴールまでの最大限進歩します

00:01:57.000 --> 00:02:01.000
それが A-star です では A-star の詳細を見ていきましょう

00:02:01.000 --> 00:02:08.000
A-star は セットアップする必要のある関数のヒューリスティック関数と呼ばれるものを使用します

00:02:08.000 --> 00:02:14.000
すべて 0 の場合は A-star は既に実装した検索アルゴリズムに再区分しなおします

00:02:14.000 --> 00:02:21.000
ヒューリスティック関数 h を呼び出すと それぞれのセルは値を持ちます

00:02:21.000 --> 00:02:23.000
では 値を入れてみます

00:02:23.000 --> 00:02:29.000
ここに 1 があります障害がない場合は ステップ数でゴールにたどり着きます

00:02:29.000 --> 00:02:34.000
見てお分かりのように 1 2 3 4 5 と入れていき

00:02:34.000 --> 00:02:37.000
障害のことは考えてないので

00:02:37.000 --> 00:02:39.000
これらは実際のゴールまでの距離は反映されていません

00:02:39.000 --> 00:02:42.000
障害のない世界では 今説明しているヒューリスティック関数は

00:02:42.000 --> 00:02:44.000
実際にゴールまでの距離を測定します

00:02:44.000 --> 00:02:51.000
ヒューリスティック関数は ゴールからどのくらい遠いのかを楽観的に想定しなければなりません

00:02:51.000 --> 00:02:58.000
では セル x y には異なるものを入れ ヒューリスティック関数は楽観的に想定しなければなりません

00:02:58.000 --> 00:03:04.000
これは 座標 x と y から実際のゴールの距離より小なりイコールになるということです

00:03:04.000 --> 00:03:06.000
ちょっとその場しのぎみたいになってきましたが

00:03:06.000 --> 00:03:09.000
とても簡単に良いヒューリスティック関数がわかることもよくあります

00:03:09.000 --> 00:03:10.000
この場合のここのように

00:03:10.000 --> 00:03:13.000
エージェントが左 右 上 または下に動けることがわかっている場合

00:03:13.000 --> 00:03:17.000
障害がない場合 エージェントがゴールにたどり着くまでのステップ数はとても簡単にわかります

00:03:17.000 --> 00:03:22.000
それを示したのがこのテーブルです

00:03:22.000 --> 00:03:25.000
それは簡単に自動生成されます

00:03:25.000 --> 00:03:27.000
では 実世界ではこれは過少見積もりです

00:03:27.000 --> 00:03:33.000
障害が たとえば こんな感じの場合 ここからゴールまで 9 ステップ以上

00:03:33.000 --> 00:03:35.000
かかります

00:03:35.000 --> 00:03:38.000
13 ステップかかってここにたどり着きます

00:03:38.000 --> 00:03:41.000
その時に ヒューリスティック関数の美しさの中にうそがあります

00:03:41.000 --> 00:03:42.000
正確である必要はありません

00:03:42.000 --> 00:03:46.000
正確なら 既にプランニングの問題を解決しています

00:03:46.000 --> 00:03:49.000
同点となる場合に 次に検索する場所がわかるように

00:03:49.000 --> 00:03:51.000
手助けする関数があるはずです

00:03:51.000 --> 00:03:57.000
それは ゴールからの本当の距離より小さいか同じにならなければなりません

00:03:57.000 --> 00:04:01.000
自動運転車では 多くの問題にこのような関数があります

00:04:01.000 --> 00:04:04.000
こんな感じの関数を私たちは使います 実際に ちょうどお見せした関数は

00:04:04.000 --> 00:04:07.000
自由形式のナビゲーションで我々のソフトウェアに使用しています

00:04:07.000 --> 00:04:13.000
それはセルステップをもっと要約できますが ユークリッドからターゲットの場所までです

00:04:13.000 --> 00:04:16.000
ヒューリスティック関数がどのようなものなのか理解いただけたことと思います

00:04:16.000 --> 00:04:20.000
ヒューリスティック関数にはたくさんの値が入ります あまり役に立ちませんが

00:04:20.000 --> 00:04:21.000
すべて 0 に設定することも含まれます

00:04:21.000 --> 00:04:23.000
では 1 つのヒューリスティック関数でやってみましょう

00:04:23.000 --> 00:04:26.000
これがコードのヒューリスティック関数です

00:04:26.000 --> 00:04:28.000
ここに同じヒューリスティック関数があります

00:04:28.000 --> 00:04:35.000
検索アルゴリズムのカギとなる変更は非常にシンプルです

00:04:35.000 --> 00:04:41.000
もう一度オープンリストを書いて 状況を追加し g 値を書きます

00:04:41.000 --> 00:04:46.000
また g 値とヒューリスティック値も書きます

00:04:46.000 --> 00:04:50.000
ここでは g 値は 0で ヒューリスティック値は 9 です

00:04:50.000 --> 00:04:53.000
その 2 つの合計は 9 で これを f 値と呼びます

00:04:53.000 --> 00:04:57.000
テーブルのここでみたように

00:04:57.000 --> 00:05:00.000
これは累積 g 値とはヒューリスティック値です

00:05:00.000 --> 00:05:07.000
ここで展開すると 一番低い g 値ではなく 一番低い f 値のエレメントを削除します

00:05:07.000 --> 00:05:08.000
それが A-star のすべてです

00:05:08.000 --> 00:05:10.000
例を示しましょう

00:05:10.000 --> 00:05:16.000
オープンリストのここをずっと下まで行ったとします

00:05:16.000 --> 00:05:19.000
それがここのすべての状況を展開しました

00:05:19.000 --> 00:05:21.000
そひて これがこのオープンリストで 1 が表示されるところです

00:05:21.000 --> 00:05:24.000
g 値は 5 になります

00:05:24.000 --> 00:05:30.000
ヒューリスティック値は 4 で 前のように合計は 9 です

00:05:30.000 --> 00:05:33.000
では このノードを展開しましょう

00:05:33.000 --> 00:05:38.000
ここにくると g 値は 6 に増えます

00:05:38.000 --> 00:05:44.000
G プラスヒューリスティック値は 9 のままです

00:05:44.000 --> 00:05:48.000
では もっと展開してみます するとやっと 2 つのオプションがでてきます

00:05:48.000 --> 00:05:51.000
このステートとここのステートです

00:05:51.000 --> 00:05:57.000
上の方が 3 2 で 右側の方が4 3です

00:05:57.000 --> 00:06:00.000
g 値はどちらも 7です

00:06:00.000 --> 00:06:04.000
でも h 値を追加すると異なってきます

00:06:04.000 --> 00:06:07.000
 ここでは h 値は 4 になります

00:06:07.000 --> 00:06:11.000
ヒューリスティックに従って ゴールから少し離してみました

00:06:11.000 --> 00:06:14.000
すると合計は 11 になります

00:06:14.000 --> 00:06:20.000
 それに対してここでは h 値は 2 になります

00:06:20.000 --> 00:06:24.000
ここではじめて A-star で違いが出ました

00:06:24.000 --> 00:06:33.000
優先でこのノードを展開し ここのノードです

00:06:33.000 --> 00:06:40.000
g と h の合計である f 値がここでは 9 になりますが ここでは 11 になる理由を見てみます

00:06:40.000 --> 00:06:45.000
これが示すことは ヒューリスティックに従うと

00:06:45.000 --> 00:06:50.000
実際にはこれは ここのこれに比べて 2 ステップゴールに近くなります

00:06:50.000 --> 00:06:53.000
これは ヒューリスティックに従うと 実際にはこれは 2 ステップ遠くなり

00:06:53.000 --> 00:06:56.000
これだと 4 ステップ遠くなります

00:06:56.000 --> 00:07:03.000
では A-star は f 値が9 対 11なので ここのノードを展開します

00:07:03.000 --> 00:07:06.000
では やってみましょう

00:07:06.000 --> 00:07:09.000
このノードを展開すると 2 つの有効なお隣りがあることがわかります

00:07:09.000 --> 00:07:11.000
これと 右側のこれです

00:07:11.000 --> 00:07:13.000
最初の座標は 3 3 です

00:07:13.000 --> 00:07:15.000
2 番目は 4 4 です

00:07:15.000 --> 00:07:18.000
前のように g 値を 1 でインクリメントします

00:07:18.000 --> 00:07:20.000
どっちの場合も 8 でした

00:07:20.000 --> 00:07:31.000
では ヒューリスティックを g 値に追加します 最初のは 3 で

00:07:31.000 --> 00:07:38.000
それに対して右側のはヒューリスティックとして 1 になります

00:07:38.000 --> 00:07:40.000
これがここのノードを展開した結果です

00:07:40.000 --> 00:07:44.000
これが新しいオープンリストです ここでも優先があります

00:07:44.000 --> 00:07:48.000
オープンリストには 3 つのステートがあり この右側のステートを優先します

00:07:48.000 --> 00:07:52.000
理由は f 値がほかの 2 つの f 値より小さいからです

00:07:52.000 --> 00:07:58.000
ここのは 9 で これらは f 値が 11 です

00:07:58.000 --> 00:08:02.000
よって もう一度展開して 展開がゴールステートになり

00:08:02.000 --> 00:08:09.000
この部分には展開することなく ゴールセットを見つけます

00:08:09.000 --> 00:08:15.000
それは魔法のようですが ここでカギとなることは 追加情報を提供することで

00:08:15.000 --> 00:08:18.000
ヒューリスティック関数と呼ばれ 検索を導くことができます

00:08:18.000 --> 00:08:24.000
手詰まりのようになったときは ゴールステートに近いノードを選びます

00:08:24.000 --> 99:59:59.999
その結果 ゴールに向かってもっと進んでるようになります

