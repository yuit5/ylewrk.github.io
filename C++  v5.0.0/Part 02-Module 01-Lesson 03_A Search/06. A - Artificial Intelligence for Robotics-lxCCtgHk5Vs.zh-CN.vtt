WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.000
现在我要带着你们到这个类的绝对核心 称为 A-star

00:00:05.000 --> 00:00:10.000
A-star 是斯坦福的 Nels Nelson 在很多年前发明的

00:00:10.000 --> 00:00:14.000
它是搜索算法的一个变体 相比展开每一个节点 它效率更高 

00:00:14.000 --> 00:00:19.000
如果你一直跟着课程学习 那么你应该对一些搜索机制有所了解

00:00:19.000 --> 00:00:24.000
它们逐渐展开 open 列表的每个节点 

00:00:24.000 --> 00:00:26.000
A-star也类似 但有不同之处

00:00:26.000 --> 00:00:30.000
为了演示 A-star 我将使用和前面相同的表格

00:00:30.000 --> 00:00:33.000
但是障碍配置有所不同

00:00:33.000 --> 00:00:36.000
这种情况下 A-star 会运行得相当不错

00:00:36.000 --> 00:00:39.000
显然 我们被迫向下到这里

00:00:39.000 --> 00:00:43.000
但是在这里我们仍然不得不搜索 寻找到达目的地的最佳路径

00:00:43.000 --> 00:00:46.000
这是与之前同样的代码 你能看到所有的障碍物

00:00:46.000 --> 00:00:49.000
开始点在这里 目标点在这里

00:00:49.000 --> 00:00:56.000
如果我运行这个代码 然后给大家显示展开列表 这个操作大家已经编程实现过了

00:00:56.000 --> 00:01:01.000
你们会发现 扩展从这里向下进行

00:01:01.000 --> 00:01:06.000
但是随后它扩展开来到达开放区域

00:01:06.000 --> 00:01:11.000
它沿着斜对角线扩展到开放区域 直到最后到达目标节点

00:01:11.000 --> 00:01:14.000
到达这一点 需要耗费16个扩展步骤 

00:01:14.000 --> 00:01:18.000
现在我切到 A-star 然后运行代码

00:01:18.000 --> 00:01:24.000
现在我们可以看到 只需要 10 个扩展步骤就可到达这一点 0 到 9

00:01:24.000 --> 00:01:28.000
它先向下扩展到 4 但是 然后它直接扩展到目标

00:01:28.000 --> 00:01:33.000
而不会探索这片区域 好像它知道

00:01:33.000 --> 00:01:37.000
在这片区域 到达目标的路径一定比直行要长

00:01:37.000 --> 00:01:38.000
我不骗你们

00:01:38.000 --> 00:01:40.000
我并没有告诉算法 这里有一条直路

00:01:40.000 --> 00:01:44.000
现在我把一个障碍放在这里 紧挨着目标 然后再运行 A-star

00:01:44.000 --> 00:01:47.000
大家会看到 它扩展到这里的7

00:01:47.000 --> 00:01:50.000
但是 随后它移动到这里的第二条线

00:01:50.000 --> 00:01:53.000
向上到这里 然后再次命中目标

00:01:53.000 --> 00:01:56.000
因此 它只做必须的最少量工作

00:01:56.000 --> 00:01:57.000
来最大化地接近目标

00:01:57.000 --> 00:02:01.000
这就是 A-star 现在我们来详细讲一下

00:02:01.000 --> 00:02:08.000
A-star 会使用一个函数 称为 “启发函数” 我们必须设置这个函数

00:02:08.000 --> 00:02:14.000
如果函数值都是0 那么 A-star 会返回去使用已经实现的搜索算法

00:02:14.000 --> 00:02:21.000
如果我们把启发函数简称 h 那么对于每个单元格 函数都会返回一个值

00:02:21.000 --> 00:02:23.000
现在 我给大家展示一些值

00:02:23.000 --> 00:02:29.000
这里是一个值 表示单元格到达目标需要的步骤数  如果没有障碍物的话

00:02:29.000 --> 00:02:34.000
显然 现在我输入的是 1 2 3 4 5 等等

00:02:34.000 --> 00:02:37.000
并不能真正反映出到达目标的距离

00:02:37.000 --> 00:02:39.000
因为我们并没有考虑障碍物

00:02:39.000 --> 00:02:42.000
在一个没有障碍物的世界中 我给大家展示的启发式函数

00:02:42.000 --> 00:02:44.000
将会真的度量到目标的距离

00:02:44.000 --> 00:02:51.000
所以 启发式函数是一个有关我们距离目标多远的乐观猜测 

00:02:51.000 --> 00:02:58.000
现在 输入不同值 对于任意单元格 x y 启发式函数做出乐观猜测

00:02:58.000 --> 00:03:04.000
得出的值比真正的距离要小

00:03:04.000 --> 00:03:06.000
听起来有点不可思议

00:03:06.000 --> 00:03:09.000
但是 大家经常可以相当容易地给出不错的启发式函数

00:03:09.000 --> 00:03:10.000
就像这里的这个例子

00:03:10.000 --> 00:03:13.000
如果我们知道代理可以移动 左 右 上 下

00:03:13.000 --> 00:03:17.000
那么我们可以非常容易地得出代理到目标点的步数

00:03:17.000 --> 00:03:22.000
如果没有障碍物的话 结果是这张表格

00:03:22.000 --> 00:03:25.000
表格很容易自动生成

00:03:25.000 --> 00:03:27.000
但是现实中 情况比这里要难很多

00:03:27.000 --> 00:03:33.000
如果有障碍 比如在这里 这种情况下

00:03:33.000 --> 00:03:35.000
从这里到目标的步数将大于9步

00:03:35.000 --> 00:03:38.000
从这里越过障碍到达目标 将需要13步

00:03:38.000 --> 00:03:41.000
这里就体现出了启发式函数的优异性

00:03:41.000 --> 00:03:42.000
它不需要很精确

00:03:42.000 --> 00:03:46.000
如果它很精确 那么你很可能已经解决了规划问题

00:03:46.000 --> 00:03:49.000
它是这样一个函数 在你陷入困境的时候

00:03:49.000 --> 00:03:51.000
帮助你确定下一步的搜索方向

00:03:51.000 --> 00:03:57.000
它的结果比实际距离小 最佳情况是与实际距离相等

00:03:57.000 --> 00:04:01.000
在我们的无人驾驶汽车里 有许多许多这样的函数

00:04:01.000 --> 00:04:04.000
我们和上面一样使用这些函数

00:04:04.000 --> 00:04:07.000
实际上 在我们的自由式导航软件中 我们就在用刚才展示的函数

00:04:07.000 --> 00:04:13.000
它计算出的单元格步骤数 其实是距离目标的欧几里得距离

00:04:13.000 --> 00:04:16.000
我希望大家可以理解 启发式函数是什么样的

00:04:16.000 --> 00:04:20.000
有很多启发函数 其中一些把所有值都设置为0

00:04:20.000 --> 00:04:21.000
当然 这样并没有什么用

00:04:21.000 --> 00:04:23.000
现在 我们来看看这个启发函数

00:04:23.000 --> 00:04:26.000
这是代码中的一个启发函数

00:04:26.000 --> 00:04:28.000
大家可以看到 这是一个同样的启发函数

00:04:28.000 --> 00:04:35.000
我们的搜索算法中 我们所做的关键性修改非常简单

00:04:35.000 --> 00:04:41.000
我们同样有个 open 列表 我们添加状态 并写下 g-value

00:04:41.000 --> 00:04:46.000
但是我们也写下 g-value 与启发值的和

00:04:46.000 --> 00:04:50.000
这里 g-value 值为0 启发值为9

00:04:50.000 --> 00:04:53.000
和是9 这个和称为 f-value

00:04:53.000 --> 00:04:57.000
这是累计的和

00:04:57.000 --> 00:05:00.000
大家看这里

00:05:00.000 --> 00:05:07.000
如果现在我要扩展 我会拿掉具有最小 f-value 的元素 而不是最小 g-value

00:05:07.000 --> 00:05:08.000
这就是 A-star

00:05:08.000 --> 00:05:10.000
我来给大家举个例子

00:05:10.000 --> 00:05:16.000
假设我们到达 open 列表的这里

00:05:16.000 --> 00:05:19.000
也就是说我们扩展这里的所有这些状态

00:05:19.000 --> 00:05:21.000
这是开放列表的一个位置

00:05:21.000 --> 00:05:24.000
g-value值为5

00:05:24.000 --> 00:05:30.000
启发值为4 和为9 和刚才一样

00:05:30.000 --> 00:05:33.000
现在扩展这个节点

00:05:33.000 --> 00:05:38.000
我们到达这里 g-value 增大到6

00:05:38.000 --> 00:05:44.000
和仍然为9

00:05:44.000 --> 00:05:48.000
我们继续扩展 这里最终有两个选择

00:05:48.000 --> 00:05:51.000
这里和这里

00:05:51.000 --> 00:05:57.000
上面的称为 3 2 右面的称为 4 3

00:05:57.000 --> 00:06:00.000
g-value 都是7

00:06:00.000 --> 00:06:04.000
但是当我们把 h-value 计算进去 结果有所不同

00:06:04.000 --> 00:06:07.000
这里的 h-value 等于4

00:06:07.000 --> 00:06:11.000
根据启发函数 在这里我们可能会远离目标

00:06:11.000 --> 00:06:14.000
因为和为11

00:06:14.000 --> 00:06:20.000
而在这里 h-value 为2

00:06:20.000 --> 00:06:24.000
在这里 A-star 第一次显示出优势

00:06:24.000 --> 00:06:33.000
它更愿意扩展到这个节点 而不是这个

00:06:33.000 --> 00:06:40.000
大家想想 为什么 g 和 h 的和 也就是 f-value 在这两处有所不同 一个是9 一个是 11

00:06:40.000 --> 00:06:45.000
原因是 按照启发值

00:06:45.000 --> 00:06:50.000
这个格子比这个格子距离目标少2步

00:06:50.000 --> 00:06:53.000
这个格子可能距离目标更远 需要多两步

00:06:53.000 --> 00:06:56.000
而这个格子可能只需4步就能到达目标

00:06:56.000 --> 00:07:03.000
A-star 会扩展这个节点 因为它的 f-value 为9 比11小

00:07:03.000 --> 00:07:06.000
现在我们继续

00:07:06.000 --> 00:07:09.000
在扩展这个节点时候 我们发现它有两个有效的相邻格子

00:07:09.000 --> 00:07:11.000
这里的和右边的

00:07:11.000 --> 00:07:13.000
第一个格子的坐标是3 3

00:07:13.000 --> 00:07:15.000
第二个是 4 4

00:07:15.000 --> 00:07:18.000
在我们给 g-value 值加1前

00:07:18.000 --> 00:07:20.000
它们都等于8

00:07:20.000 --> 00:07:31.000
现在我们把启发值加到 g-value 上 第一个格子结果为3

00:07:31.000 --> 00:07:38.000
而右边的格子值等于启发值

00:07:38.000 --> 00:07:40.000
这就是扩展节点到这里的结果

00:07:40.000 --> 00:07:44.000
这里是我们的新的开放列表 我们再次有一个偏好

00:07:44.000 --> 00:07:48.000
对于开放列表中的这三个状态 我们更加偏好右边这个

00:07:48.000 --> 00:07:52.000
因为它的 f-value 最小

00:07:52.000 --> 00:07:58.000
这个是9 这个是11

00:07:58.000 --> 00:08:02.000
接下来 我们继续扩展 在这里就接近了目标状态

00:08:02.000 --> 00:08:09.000
到这里 我们就到达了目标 在此过程中 我们并没有在图中的这个区域扩展

00:08:09.000 --> 00:08:15.000
看起来有点不可思议 这里的关键是我们拥有额外信息

00:08:15.000 --> 00:08:18.000
那就是 启发函数 用来引导搜索

00:08:18.000 --> 00:08:24.000
当我们面临抉择 我们可以靠它来选择看起来离目标最近的节点

00:08:24.000 --> 99:59:59.999
结果是 我们将很可能向目标继续前进

